<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tr√≤ Ch∆°i C·ªù Caro 10x10 Vui Nh·ªôn!</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(to right, #a7f3d0, #6ee7b7); /* M√†u n·ªÅn gradient t∆∞∆°i s√°ng */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: auto; /* Cho ph√©p cu·ªôn trang n·∫øu b√†n c·ªù l·ªõn h∆°n m√†n h√¨nh */
            padding: 20px; /* Th√™m padding ƒë·ªÉ tr√°nh b√†n c·ªù ch·∫°m m√©p */
        }
        .container {
            background-color: #ffffff;
            border-radius: 20px; /* Bo tr√≤n c√°c g√≥c */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2); /* ƒê·ªï b√≥ng nh·∫π nh√†ng */
            padding: 30px;
            text-align: center;
            max-width: 100%; /* ƒê·∫£m b·∫£o responsive */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        h1 {
            font-size: 2.5rem; /* K√≠ch th∆∞·ªõc ti√™u ƒë·ªÅ l·ªõn */
            color: #10b981; /* M√†u xanh l√° c√¢y ƒë·∫≠m */
            margin-bottom: 20px;
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        .game-board {
            display: grid;
            /* Grid columns and rows will be set dynamically by JS */
            background-color: #d1fae5; /* N·ªÅn b·∫£ng m√†u xanh nh·∫°t */
            border-radius: 15px;
            padding: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
            /* Ensure board fits within container and is responsive */
            max-width: 100%;
            overflow: auto; /* Allow scrolling if board is too big */
        }
        .cell {
            width: 35px; /* K√≠ch th∆∞·ªõc √¥ c·ªë ƒë·ªãnh, ƒëi·ªÅu ch·ªânh cho 10x10 */
            height: 35px;
            background-color: #ecfdf5; /* N·ªÅn √¥ m√†u tr·∫Øng xanh */
            border-radius: 5px; /* Bo tr√≤n g√≥c √¥ nh·ªè h∆°n */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem; /* K√≠ch th∆∞·ªõc ch·ªØ X/O ph√π h·ª£p v·ªõi √¥ nh·ªè h∆°n */
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            color: #059669; /* M√†u ch·ªØ m·∫∑c ƒë·ªãnh */
            user-select: none; /* NgƒÉn ch·ªçn vƒÉn b·∫£n */
            box-sizing: border-box; /* ƒê·∫£m b·∫£o padding/border kh√¥ng l√†m tƒÉng k√≠ch th∆∞·ªõc √¥ */
        }
        .cell:hover {
            background-color: #d1fae5; /* ƒê·ªïi m√†u khi hover */
        }
        .cell.X {
            color: #ef4444; /* M√†u ƒë·ªè cho X */
        }
        .cell.O {
            color: #3b82f6; /* M√†u xanh d∆∞∆°ng cho O */
        }
        .status-display {
            font-size: 1.5rem;
            color: #065f46; /* M√†u ch·ªØ tr·∫°ng th√°i */
            font-weight: 600;
            margin-top: 10px;
            min-height: 30px; /* ƒê·∫£m b·∫£o kh√¥ng b·ªã nh·∫£y layout */
        }
        .reset-button {
            background: linear-gradient(to right, #34d399, #10b981); /* N√∫t reset gradient */
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 15px; /* Bo tr√≤n n√∫t */
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: background 0.3s ease, transform 0.2s ease;
        }
        .reset-button:hover {
            background: linear-gradient(to right, #10b981, #059669);
            transform: translateY(-2px); /* Hi·ªáu ·ª©ng nh·∫•n n√∫t */
        }
        .reset-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* Message Box Styling */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 25px 35px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            gap: 20px;
            max-width: 90%;
            text-align: center;
        }
        .message-box-content {
            font-size: 1.8rem;
            color: #065f46;
            font-weight: 600;
        }
        .message-box-button {
            background: linear-gradient(to right, #34d399, #10b981);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.2s ease;
        }
        .message-box-button:hover {
            background: linear-gradient(to right, #10b981, #059669);
            transform: translateY(-1px);
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
            display: none; /* Hidden by default */
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            .container {
                padding: 15px;
                width: 98%;
            }
            .cell {
                width: 30px; /* Gi·∫£m k√≠ch th∆∞·ªõc √¥ tr√™n m√†n h√¨nh nh·ªè h∆°n */
                height: 30px;
                font-size: 1.5rem;
            }
            .status-display {
                font-size: 1.2rem;
            }
            .reset-button {
                padding: 10px 20px;
                font-size: 1rem;
            }
            .message-box-content {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Tr√≤ Ch∆°i C·ªù Caro ü•≥</h1>
        <div id="status" class="status-display">L∆∞·ª£t c·ªßa: B·∫°n (X)</div>
        <div class="game-board" id="gameBoard">
            <!-- Cells will be dynamically generated by JavaScript -->
        </div>
        <button id="resetButton" class="reset-button">Ch∆°i L·∫°i!</button>
    </div>

    <!-- Message Box -->
    <div id="overlay" class="overlay"></div>
    <div id="messageBox" class="message-box">
        <div id="messageBoxContent" class="message-box-content"></div>
        <button id="messageBoxButton" class="message-box-button">ƒê√≥ng</button>
    </div>

    <script>
        // L·∫•y c√°c ph·∫ßn t·ª≠ DOM
        const gameBoard = document.getElementById('gameBoard');
        const statusDisplay = document.getElementById('status');
        const resetButton = document.getElementById('resetButton');
        const messageBox = document.getElementById('messageBox');
        const messageBoxContent = document.getElementById('messageBoxContent');
        const messageBoxButton = document.getElementById('messageBoxButton');
        const overlay = document.getElementById('overlay');

        // Bi·∫øn tr·∫°ng th√°i tr√≤ ch∆°i
        const BOARD_SIZE = 10; // K√≠ch th∆∞·ªõc b√†n c·ªù (10x10)
        let board = []; // M·∫£ng 2 chi·ªÅu l∆∞u tr·ªØ tr·∫°ng th√°i c√°c √¥
        const humanPlayer = 'X'; // K√Ω hi·ªáu ng∆∞·ªùi ch∆°i
        const computerPlayer = 'O'; // K√Ω hi·ªáu m√°y t√≠nh
        let gameActive = true; // Tr·∫°ng th√°i tr√≤ ch∆°i ƒëang di·ªÖn ra hay ƒë√£ k·∫øt th√∫c
        let currentPlayer = humanPlayer; // Ng∆∞·ªùi ch∆°i hi·ªán t·∫°i, b·∫Øt ƒë·∫ßu b·∫±ng ng∆∞·ªùi

        // H√†m hi·ªÉn th·ªã th√¥ng b√°o
        function showMessage(message) {
            messageBoxContent.textContent = message;
            messageBox.style.display = 'flex';
            overlay.style.display = 'block';
        }

        // H√†m ·∫©n th√¥ng b√°o
        function hideMessage() {
            messageBox.style.display = 'none';
            overlay.style.display = 'none';
        }

        // H√†m kh·ªüi t·∫°o b√†n c·ªù
        function initializeBoard() {
            gameBoard.style.gridTemplateColumns = `repeat(${BOARD_SIZE}, 1fr)`;
            gameBoard.style.gridTemplateRows = `repeat(${BOARD_SIZE}, 1fr)`;
            gameBoard.innerHTML = ''; // X√≥a c√°c √¥ hi·ªán c√≥

            board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill('')); // T·∫°o m·∫£ng 2 chi·ªÅu

            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.addEventListener('click', handleCellClick);
                    gameBoard.appendChild(cell);
                }
            }
        }

        // H√†m ki·ªÉm tra xem m·ªôt v·ªã tr√≠ c√≥ h·ª£p l·ªá trong b√†n c·ªù kh√¥ng
        const isValid = (r, c) => r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE;
        // const isPlayerMark = (br, bc, p) => isValid(br, bc) && board[br][bc] === p; // Not directly used in minimax
        // const isEmpty = (br, bc) => isValid(br, bc) && board[br][bc] === ''; // Not directly used in minimax


        // H√†m ki·ªÉm tra 5 c·ªù li√™n t·ª•c kh√¥ng b·ªã ch·∫∑n 2 ƒë·∫ßu
        function checkWin(currentBoard, player) { // Th√™m currentBoard l√†m tham s·ªë
            const WIN_COUNT = 5;

            const isCurrentPlayerMark = (r, c, p) => isValid(r, c) && currentBoard[r][c] === p;
            const isOpponentMark = (r, c, p) => isValid(r, c) && currentBoard[r][c] !== '' && currentBoard[r][c] !== p;

            // C√°c h∆∞·ªõng ƒë·ªÉ ki·ªÉm tra: ngang, d·ªçc, ch√©o (\), ch√©o (/)
            const directions = [
                [0, 1],  // Ngang
                [1, 0],  // D·ªçc
                [1, 1],  // Ch√©o \
                [1, -1]  // Ch√©o /
            ];

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (currentBoard[r][c] === player) {
                        for (const [dr, dc] of directions) {
                            let count = 1;
                            let blockedEnds = 0;

                            // Ki·ªÉm tra v·ªÅ ph√≠a tr∆∞·ªõc
                            for (let i = 1; i < WIN_COUNT; i++) {
                                const nr = r + i * dr;
                                const nc = c + i * dc;
                                if (isCurrentPlayerMark(nr, nc, player)) {
                                    count++;
                                } else {
                                    break;
                                }
                            }

                            if (count >= WIN_COUNT) {
                                // Ki·ªÉm tra ch·∫∑n ·ªü ƒë·∫ßu chu·ªói ti·ªÅm nƒÉng
                                const prevR = r - dr;
                                const prevC = c - dc;
                                if (isOpponentMark(prevR, prevC, player)) {
                                    blockedEnds++;
                                }

                                // Ki·ªÉm tra ch·∫∑n ·ªü cu·ªëi chu·ªói ti·ªÅm nƒÉng
                                const endR = r + (WIN_COUNT - 1) * dr;
                                const endC = c + (WIN_COUNT - 1) * dc;
                                const nextR = endR + dr;
                                const nextC = endC + dc;
                                if (isOpponentMark(nextR, nextC, player)) {
                                    blockedEnds++;
                                }

                                // N·∫øu 5 c·ªù li√™n t·ª•c v√† kh√¥ng b·ªã ch·∫∑n c·∫£ hai ƒë·∫ßu, th√¨ th·∫Øng
                                if (blockedEnds < 2) { // Nh·ªè h∆°n 2 nghƒ©a l√† 0 ho·∫∑c 1 ƒë·∫ßu b·ªã ch·∫∑n
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }

        // H√†m ƒë√°nh gi√° ƒëi·ªÉm chi·∫øn l∆∞·ª£c cho m·ªôt tr·∫°ng th√°i b√†n c·ªù t·ª´ g√≥c nh√¨n c·ªßa m·ªôt ng∆∞·ªùi ch∆°i
        function evaluateBoard(currentBoard, player) {
            let score = 0;
            const opponent = player === humanPlayer ? computerPlayer : humanPlayer;
            const WIN_COUNT = 5;

            const directions = [
                [0, 1],  // Ngang
                [1, 0],  // D·ªçc
                [1, 1],  // Ch√©o \
                [1, -1]  // Ch√©o /
            ];

            // ƒê·ªãnh nghƒ©a ƒëi·ªÉm cho c√°c m·∫´u c·ªù kh√°c nhau
            const scores = {
                'WIN': 10000000, // Th·∫Øng ngay l·∫≠p t·ª©c
                'S4_OPEN': 1000000, // S·ªëng 4 (4 qu√¢n, 2 ƒë·∫ßu tr·ªëng)
                'S4_HALF': 100000, // Ch·∫øt 4 (4 qu√¢n, 1 ƒë·∫ßu tr·ªëng)
                'S3_OPEN': 10000, // S·ªëng 3 (3 qu√¢n, 2 ƒë·∫ßu tr·ªëng)
                'S3_HALF': 1000, // Ch·∫øt 3 (3 qu√¢n, 1 ƒë·∫ßu tr·ªëng)
                'S2_OPEN': 100, // S·ªëng 2 (2 qu√¢n, 2 ƒë·∫ßu tr·ªëng)
                'S2_HALF': 10, // Ch·∫øt 2 (2 qu√¢n, 1 ƒë·∫ßu tr·ªëng)
                'S1_OPEN': 1 // S·ªëng 1 (1 qu√¢n, 2 ƒë·∫ßu tr·ªëng)
            };

            // H√†m tr·ª£ gi√∫p ƒë·ªÉ ƒë·∫øm c√°c m·∫´u c·ªù cho m·ªôt ng∆∞·ªùi ch∆°i c·ª• th·ªÉ
            function countPatterns(boardState, p) {
                let p_score = 0;
                const opp = p === humanPlayer ? computerPlayer : humanPlayer;

                const isCurrentPlayerMark = (r, c, playerSymbol) => isValid(r, c) && boardState[r][c] === playerSymbol;
                const isOpponentMark = (r, c, oppSymbol) => isValid(r, c) && boardState[r][c] !== '' && boardState[r][c] === oppSymbol;
                const isEmptySpot = (r, c) => isValid(r, c) && boardState[r][c] === '';

                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (boardState[r][c] === p) {
                            for (const [dr, dc] of directions) {
                                // Duy·ªát qua c√°c ƒëo·∫°n 5 √¥ c√≥ th·ªÉ b·∫Øt ƒë·∫ßu t·ª´ (r,c)
                                for (let offset = -(WIN_COUNT - 1); offset <= 0; offset++) {
                                    let startR = r + offset * dr;
                                    let startC = c + offset * dc;

                                    let consecutive = 0;
                                    let openEnds = 0;
                                    let blockedByOpponentInLine = 0; // ƒê·∫øm s·ªë l∆∞·ª£ng qu√¢n ƒë·ªëi th·ªß trong chu·ªói 5 √¥

                                    for (let i = 0; i < WIN_COUNT; i++) {
                                        const currR = startR + i * dr;
                                        const currC = startC + i * dc;

                                        if (!isValid(currR, currC)) {
                                            blockedByOpponentInLine++; // Coi nh∆∞ b·ªã ch·∫∑n b·ªüi c·∫°nh b√†n c·ªù
                                            break;
                                        }

                                        if (boardState[currR][currC] === p) {
                                            consecutive++;
                                        } else if (boardState[currR][currC] === opp) {
                                            blockedByOpponentInLine++; // B·ªã ch·∫∑n b·ªüi qu√¢n ƒë·ªëi th·ªß
                                            break;
                                        }
                                    }

                                    if (blockedByOpponentInLine > 0) continue; // ƒêo·∫°n n√†y ƒë√£ b·ªã ch·∫∑n ho·∫∑c ra ngo√†i bi√™n

                                    // Ki·ªÉm tra ƒë·ªô m·ªü ·ªü hai ƒë·∫ßu c·ªßa ƒëo·∫°n 5 √¥
                                    const beforeR = startR - dr;
                                    const beforeC = startC - dc;
                                    const afterR = startR + WIN_COUNT * dr;
                                    const afterC = startC + WIN_COUNT * dc;

                                    if (isEmptySpot(beforeR, beforeC)) {
                                        openEnds++;
                                    } else if (isOpponentMark(beforeR, beforeC, opp)) {
                                        blockedByOpponentInLine++;
                                    }

                                    if (isEmptySpot(afterR, afterC)) {
                                        openEnds++;
                                    } else if (isOpponentMark(afterR, afterC, opp)) {
                                        blockedByOpponentInLine++;
                                    }

                                    if (blockedByOpponentInLine >= 2) continue; // C·∫£ hai ƒë·∫ßu ƒë·ªÅu b·ªã ch·∫∑n b·ªüi ƒë·ªëi th·ªß ho·∫∑c c·∫°nh

                                    // G√°n ƒëi·ªÉm d·ª±a tr√™n c√°c m·∫´u
                                    if (consecutive === 5) p_score += scores['WIN'];
                                    else if (consecutive === 4 && openEnds === 2) p_score += scores['S4_OPEN'];
                                    else if (consecutive === 4 && openEnds === 1) p_score += scores['S4_HALF'];
                                    else if (consecutive === 3 && openEnds === 2) p_score += scores['S3_OPEN'];
                                    else if (consecutive === 3 && openEnds === 1) p_score += scores['S3_HALF'];
                                    else if (consecutive === 2 && openEnds === 2) p_score += scores['S2_OPEN'];
                                    else if (consecutive === 2 && openEnds === 1) p_score += scores['S2_HALF'];
                                    else if (consecutive === 1 && openEnds === 2) p_score += scores['S1_OPEN'];
                                }
                            }
                        }
                    }
                }
                return p_score;
            }

            // T√≠nh ƒëi·ªÉm cho ng∆∞·ªùi ch∆°i hi·ªán t·∫°i v√† ƒë·ªëi th·ªß
            const player_score = countPatterns(currentBoard, player);
            const opponent_score = countPatterns(currentBoard, opponent);

            // Tr·∫£ v·ªÅ hi·ªáu s·ªë ƒëi·ªÉm (l·ª£i th·∫ø c·ªßa ng∆∞·ªùi ch∆°i hi·ªán t·∫°i)
            return player_score - opponent_score;
        }

        // Thu·∫≠t to√°n Minimax v·ªõi c·∫Øt t·ªâa Alpha-Beta
        function minimax(currentBoard, depth, isMaximizingPlayer, alpha, beta) {
            // Ki·ªÉm tra c√°c tr∆∞·ªùng h·ª£p c∆° s·ªü
            if (checkWin(currentBoard, computerPlayer)) {
                return 1000000000; // M√°y th·∫Øng v·ªõi ƒëi·ªÉm r·∫•t cao
            }
            if (checkWin(currentBoard, humanPlayer)) {
                return -1000000000; // Ng∆∞·ªùi th·∫Øng v·ªõi ƒëi·ªÉm r·∫•t th·∫•p
            }

            const availableCells = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (currentBoard[r][c] === '') {
                        availableCells.push({ row: r, col: c });
                    }
                }
            }

            if (availableCells.length === 0) {
                return 0; // H√≤a
            }
            if (depth === 0) {
                return evaluateBoard(currentBoard, computerPlayer); // ƒê√°nh gi√° tr·∫°ng th√°i b√†n c·ªù t·ª´ g√≥c nh√¨n c·ªßa m√°y
            }

            if (isMaximizingPlayer) { // L∆∞·ª£t c·ªßa m√°y (c·ªë g·∫Øng t·ªëi ƒëa h√≥a ƒëi·ªÉm)
                let bestScore = -Infinity;
                for (const { row, col } of availableCells) {
                    currentBoard[row][col] = computerPlayer; // Th·ª±c hi·ªán n∆∞·ªõc ƒëi t·∫°m th·ªùi
                    const score = minimax(currentBoard, depth - 1, false, alpha, beta);
                    currentBoard[row][col] = ''; // Ho√†n t√°c n∆∞·ªõc ƒëi

                    bestScore = Math.max(bestScore, score);
                    alpha = Math.max(alpha, bestScore);
                    if (beta <= alpha) {
                        break; // C·∫Øt t·ªâa Alpha-Beta
                    }
                }
                return bestScore;
            } else { // L∆∞·ª£t c·ªßa ng∆∞·ªùi (c·ªë g·∫Øng t·ªëi thi·ªÉu h√≥a ƒëi·ªÉm c·ªßa m√°y)
                let bestScore = Infinity;
                for (const { row, col } of availableCells) {
                    currentBoard[row][col] = humanPlayer; // Th·ª±c hi·ªán n∆∞·ªõc ƒëi t·∫°m th·ªùi
                    const score = minimax(currentBoard, depth - 1, true, alpha, beta);
                    currentBoard[row][col] = ''; // Ho√†n t√°c n∆∞·ªõc ƒëi

                    bestScore = Math.min(bestScore, score);
                    beta = Math.min(beta, bestScore);
                    if (beta <= alpha) {
                        break; // C·∫Øt t·ªâa Alpha-Beta
                    }
                }
                return bestScore;
            }
        }

        // H√†m ƒë·ªÉ m√°y t√≠nh th·ª±c hi·ªán n∆∞·ªõc ƒëi
        function makeComputerMove() {
            gameActive = false; // T·∫°m th·ªùi v√¥ hi·ªáu h√≥a click trong l∆∞·ª£t c·ªßa m√°y
            statusDisplay.textContent = 'M√°y ƒëang suy nghƒ©... ü§î';

            setTimeout(() => {
                const availableCells = [];
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[r][c] === '') {
                            availableCells.push({ row: r, col: c });
                        }
                    }
                }

                if (availableCells.length === 0) {
                    handleResultValidation(); // B√†n c·ªù ƒë·∫ßy, x·ª≠ l√Ω h√≤a
                    return;
                }

                let bestScore = -Infinity;
                let bestMove = null;
                const MAX_DEPTH = 3; // Gi·ªõi h·∫°n ƒë·ªô s√¢u t√¨m ki·∫øm Minimax

                // S·∫Øp x·∫øp ng·∫´u nhi√™n c√°c √¥ tr·ªëng ƒë·ªÉ th√™m m·ªôt ch√∫t ng·∫´u nhi√™n n·∫øu ƒëi·ªÉm s·ªë b·∫±ng nhau
                // ƒêi·ªÅu n√†y gi√∫p m√°y kh√¥ng lu√¥n ch·ªçn c√πng m·ªôt n∆∞·ªõc ƒëi trong c√°c t√¨nh hu·ªëng t∆∞∆°ng t·ª±
                availableCells.sort(() => Math.random() - 0.5);

                for (const { row, col } of availableCells) {
                    // T·∫°o m·ªôt b·∫£n sao s√¢u c·ªßa b√†n c·ªù ƒë·ªÉ m√¥ ph·ªèng Minimax
                    const boardCopy = board.map(arr => [...arr]);
                    boardCopy[row][col] = computerPlayer; // Th·ª±c hi·ªán n∆∞·ªõc ƒëi c·ªßa m√°y tr√™n b·∫£n sao

                    // G·ªçi Minimax ƒë·ªÉ ƒë√°nh gi√° n∆∞·ªõc ƒëi n√†y
                    // B·∫Øt ƒë·∫ßu v·ªõi ƒë·ªô s√¢u MAX_DEPTH - 1 v√¨ n∆∞·ªõc ƒëi hi·ªán t·∫°i ƒë√£ chi·∫øm 1 ƒë·ªô s√¢u
                    const score = minimax(boardCopy, MAX_DEPTH - 1, false, -Infinity, Infinity);

                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = { row, col };
                    }
                }

                // Th·ª±c hi·ªán n∆∞·ªõc ƒëi t·ªët nh·∫•t t√¨m ƒë∆∞·ª£c
                if (bestMove) {
                    performMove(bestMove.row, bestMove.col, computerPlayer);
                } else {
                    // Tr∆∞·ªùng h·ª£p d·ª± ph√≤ng: n·∫øu kh√¥ng t√¨m th·∫•y n∆∞·ªõc ƒëi chi·∫øn l∆∞·ª£c n√†o (r·∫•t hi·∫øm v·ªõi Minimax)
                    // Ch·ªçn m·ªôt √¥ tr·ªëng ng·∫´u nhi√™n
                    const randomIndex = Math.floor(Math.random() * availableCells.length);
                    bestMove = availableCells[randomIndex];
                    performMove(bestMove.row, bestMove.col, computerPlayer);
                }

            }, 800); // ƒê·ªô tr·ªÖ nh·ªè cho n∆∞·ªõc ƒëi c·ªßa m√°y
        }

        // H√†m th·ª±c hi·ªán n∆∞·ªõc ƒëi (cho c·∫£ ng∆∞·ªùi v√† m√°y)
        function performMove(row, col, player) {
            board[row][col] = player;
            const cellElement = gameBoard.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            cellElement.textContent = player === 'X' ? '‚ùå' : '‚≠ï';
            cellElement.classList.add(player);
            handleResultValidation();
        }

        // H√†m x·ª≠ l√Ω khi ng∆∞·ªùi ch∆°i click v√†o m·ªôt √¥
        function handleCellClick(event) {
            const clickedCell = event.target;
            const row = parseInt(clickedCell.dataset.row);
            const col = parseInt(clickedCell.dataset.col);

            // N·∫øu √¥ ƒë√£ c√≥ ng∆∞·ªùi ƒë√°nh, tr√≤ ch∆°i ƒë√£ k·∫øt th√∫c, ho·∫∑c kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa ng∆∞·ªùi, kh√¥ng l√†m g√¨ c·∫£
            if (board[row][col] !== '' || !gameActive || currentPlayer !== humanPlayer) {
                return;
            }

            // Ng∆∞·ªùi ch∆°i th·ª±c hi·ªán n∆∞·ªõc ƒëi
            performMove(row, col, humanPlayer);

            // N·∫øu tr√≤ ch∆°i v·∫´n ƒëang di·ªÖn ra, ƒë·∫øn l∆∞·ª£t m√°y
            if (gameActive) {
                currentPlayer = computerPlayer; // Chuy·ªÉn l∆∞·ª£t sang m√°y (trong logic)
                makeComputerMove();
            }
        }

        // H√†m ki·ªÉm tra k·∫øt qu·∫£ tr√≤ ch∆°i (th·∫Øng, h√≤a, ti·∫øp t·ª•c)
        function handleResultValidation() {
            let roundWon = false;
            let winner = '';

            if (checkWin(board, humanPlayer)) { // Truy·ªÅn board v√†o checkWin
                roundWon = true;
                winner = humanPlayer;
            } else if (checkWin(board, computerPlayer)) { // Truy·ªÅn board v√†o checkWin
                roundWon = true;
                winner = computerPlayer;
            }

            if (roundWon) {
                if (winner === humanPlayer) {
                    showMessage(`üéâ B·∫°n ƒë√£ th·∫Øng! üéâ`);
                } else {
                    showMessage(`üò≠ M√°y ƒë√£ th·∫Øng! üò≠`);
                }
                gameActive = false; // K·∫øt th√∫c tr√≤ ch∆°i
                return;
            }

            // Ki·ªÉm tra h√≤a (t·∫•t c·∫£ c√°c √¥ ƒë·ªÅu ƒë√£ ƒë∆∞·ª£c ƒë√°nh v√† kh√¥ng ai th·∫Øng)
            const availableCells = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === '') {
                        availableCells.push({ row: r, col: c });
                    }
                }
            }
            let roundDraw = availableCells.length === 0;
            if (roundDraw) {
                showMessage(`ü§ù Tr√≤ ch∆°i h√≤a! ü§ù`);
                gameActive = false; // K·∫øt th√∫c tr√≤ ch∆°i
                return;
            }

            // N·∫øu ch∆∞a c√≥ k·∫øt qu·∫£, chuy·ªÉn l∆∞·ª£t ch∆°i (hi·ªÉn th·ªã) v√† cho ph√©p click l·∫°i
            currentPlayer = currentPlayer === humanPlayer ? computerPlayer : humanPlayer; // D√≤ng n√†y ch·ªß y·∫øu ƒë·ªÉ d·ª± ph√≤ng n·∫øu th√™m ch·∫ø ƒë·ªô 2 ng∆∞·ªùi ch∆°i
            statusDisplay.textContent = `L∆∞·ª£t c·ªßa: B·∫°n (X)`; // Lu√¥n hi·ªÉn th·ªã l∆∞·ª£t c·ªßa ng∆∞·ªùi sau khi m√°y ƒë√°nh
            gameActive = true; // Cho ph√©p click l·∫°i sau l∆∞·ª£t c·ªßa m√°y
        }

        // H√†m kh·ªüi ƒë·ªông l·∫°i tr√≤ ch∆°i
        function handleRestartGame() {
            gameActive = true; // K√≠ch ho·∫°t tr√≤ ch∆°i
            currentPlayer = humanPlayer; // B·∫Øt ƒë·∫ßu l·∫°i v·ªõi ng∆∞·ªùi ch∆°i
            statusDisplay.textContent = `L∆∞·ª£t c·ªßa: B·∫°n (X)`; // C·∫≠p nh·∫≠t tr·∫°ng th√°i
            initializeBoard(); // Kh·ªüi t·∫°o l·∫°i b√†n c·ªù v√† c√°c √¥
            hideMessage(); // ·∫®n h·ªôp tho·∫°i th√¥ng b√°o
        }

        // G√°n s·ª± ki·ªán click cho n√∫t "Ch∆°i L·∫°i"
        resetButton.addEventListener('click', handleRestartGame);

        // G√°n s·ª± ki·ªán click cho n√∫t ƒë√≥ng trong h·ªôp tho·∫°i th√¥ng b√°o
        messageBoxButton.addEventListener('click', hideMessage);

        // Kh·ªüi t·∫°o b√†n c·ªù khi trang t·∫£i
        window.onload = () => {
            initializeBoard();
            hideMessage();
        };
    </script>
</body>
</html>
