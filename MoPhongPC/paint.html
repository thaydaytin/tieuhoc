<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S√¢n Ch∆°i V·∫Ω</title>
    <!-- Th∆∞ vi·ªán Tailwind CSS ƒë·ªÉ t·∫°o giao di·ªán ƒë·∫πp m·∫Øt -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* T√πy ch·ªânh CSS cho giao di·ªán */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        #paint-canvas {
            border: 2px solid #a5b4fc;
            background-color: #ffffff;
            cursor: crosshair;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border-radius: 1rem;
            touch-action: none;
        }
        .tool-button.active {
            box-shadow: inset 0 2px 4px 0 rgba(0,0,0,0.2);
            border-color: #4f46e5;
            transform: translateY(2px);
        }
    </style>
</head>
<body class="flex flex-col items-center p-5">

    <h1 class="text-4xl md:text-5xl font-bold text-gray-800 mb-6">S√¢n Ch∆°i V·∫Ω</h1>
    
    <!-- Thanh c√¥ng c·ª• -->
    <div class="toolbar-container bg-white p-6 rounded-3xl shadow-2xl mb-8 flex flex-wrap items-center justify-center gap-4">
        
        <!-- C√°c c√¥ng c·ª• v·∫Ω -->
        <div class="flex items-center space-x-2">
            <label class="font-bold text-gray-700">C√¥ng c·ª•:</label>
            <button id="tool-pencil" class="tool-button active p-3 rounded-xl bg-yellow-200 hover:bg-yellow-300 transition-colors duration-200 shadow-md">‚úèÔ∏è</button>
            <button id="tool-eraser" class="tool-button p-3 rounded-xl bg-purple-200 hover:bg-purple-300 transition-colors duration-200 shadow-md">üßº</button>
            <button id="tool-square" class="tool-button p-3 rounded-xl bg-orange-200 hover:bg-orange-300 transition-colors duration-200 shadow-md">üü•</button>
            <button id="tool-circle" class="tool-button p-3 rounded-xl bg-sky-200 hover:bg-sky-300 transition-colors duration-200 shadow-md">üîµ</button>
        </div>

        <!-- Ch·ªçn m√†u s·∫Øc -->
        <div class="flex items-center space-x-2">
            <label for="color-picker" class="font-bold text-gray-700">M√†u s·∫Øc:</label>
            <input type="color" id="color-picker" value="#000000" class="w-12 h-12 rounded-xl cursor-pointer overflow-hidden border-2 border-gray-300">
        </div>

        <!-- Ch·ªçn k√≠ch th∆∞·ªõc n√©t v·∫Ω -->
        <div class="flex flex-col items-center space-y-1">
            <label for="brush-size" class="font-bold text-gray-700">K√≠ch th∆∞·ªõc:</label>
            <input type="range" id="brush-size" min="1" max="50" value="5" class="w-32 h-3 rounded-full appearance-none bg-indigo-200 cursor-pointer">
            <span id="brush-size-value" class="text-gray-600 font-bold text-sm">5</span>
        </div>

        <!-- C√°c n√∫t ch·ª©c nƒÉng -->
        <div class="flex space-x-2">
            <button id="clear-button" class="bg-red-500 text-white font-bold py-3 px-6 rounded-xl shadow-md hover:bg-red-600 transition-colors duration-200">
                X√≥a H·∫øt
            </button>
            <button id="save-button" class="bg-green-500 text-white font-bold py-3 px-6 rounded-xl shadow-md hover:bg-green-600 transition-colors duration-200">
                L∆∞u ·∫¢nh
            </button>
        </div>
    </div>

    <!-- Khung v·∫Ω -->
    <canvas id="paint-canvas" width="800" height="600" class="w-full max-w-4xl h-96"></canvas>

    <!-- ƒêo·∫°n m√£ JavaScript ƒë·ªÉ x·ª≠ l√Ω logic v·∫Ω -->
    <script>
        // L·∫•y c√°c ph·∫ßn t·ª≠ t·ª´ DOM
        const canvas = document.getElementById('paint-canvas');
        const context = canvas.getContext('2d');
        const colorPicker = document.getElementById('color-picker');
        const brushSizeSlider = document.getElementById('brush-size');
        const brushSizeValue = document.getElementById('brush-size-value');
        const clearButton = document.getElementById('clear-button');
        const saveButton = document.getElementById('save-button');
        const toolButtons = document.querySelectorAll('.tool-button');
        
        // L·∫•y c√°c n√∫t c√¥ng c·ª•
        const pencilToolButton = document.getElementById('tool-pencil');
        const eraserToolButton = document.getElementById('tool-eraser');
        const squareToolButton = document.getElementById('tool-square');
        const circleToolButton = document.getElementById('tool-circle');

        // Kh·ªüi t·∫°o c√°c bi·∫øn tr·∫°ng th√°i
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentTool = 'pencil'; // B√∫t ch√¨ l√† c√¥ng c·ª• m·∫∑c ƒë·ªãnh
        let startX = 0;
        let startY = 0;
        let canvasSnapshot; // L∆∞u tr·∫°ng th√°i canvas khi b·∫Øt ƒë·∫ßu v·∫Ω h√¨nh kh·ªëi
        
        // Thi·∫øt l·∫≠p ban ƒë·∫ßu cho context
        context.lineCap = 'round';
        context.lineJoin = 'round';
        context.fillStyle = '#ffffff'; // M√†u n·ªÅn m·∫∑c ƒë·ªãnh
        context.fillRect(0, 0, canvas.width, canvas.height); // T√¥ m√†u n·ªÅn cho canvas
        context.strokeStyle = colorPicker.value;
        context.lineWidth = brushSizeSlider.value;

        // C·∫≠p nh·∫≠t gi√° tr·ªã k√≠ch th∆∞·ªõc n√©t v·∫Ω khi thanh tr∆∞·ª£t thay ƒë·ªïi
        brushSizeSlider.addEventListener('input', () => {
            context.lineWidth = brushSizeSlider.value;
            brushSizeValue.textContent = brushSizeSlider.value;
        });

        // C·∫≠p nh·∫≠t m√†u s·∫Øc khi ng∆∞·ªùi d√πng ch·ªçn m√†u m·ªõi
        colorPicker.addEventListener('input', (e) => {
            context.strokeStyle = e.target.value;
            context.globalCompositeOperation = 'source-over'; // Tr·∫£ l·∫°i ch·∫ø ƒë·ªô v·∫Ω b√¨nh th∆∞·ªùng
        });

        // X·ª≠ l√Ω s·ª± ki·ªán ch·ªçn c√¥ng c·ª•
        toolButtons.forEach(button => {
            button.addEventListener('click', () => {
                // X√≥a tr·∫°ng th√°i active c·ªßa t·∫•t c·∫£ c√°c n√∫t
                toolButtons.forEach(btn => btn.classList.remove('active'));
                // Th√™m tr·∫°ng th√°i active cho n√∫t ƒë∆∞·ª£c ch·ªçn
                button.classList.add('active');
                
                // C·∫≠p nh·∫≠t c√¥ng c·ª• hi·ªán t·∫°i
                if (button.id === 'tool-pencil') {
                    currentTool = 'pencil';
                    context.globalCompositeOperation = 'source-over'; // Tr·∫£ l·∫°i ch·∫ø ƒë·ªô v·∫Ω b√¨nh th∆∞·ªùng
                } else if (button.id === 'tool-eraser') {
                    currentTool = 'eraser';
                    context.globalCompositeOperation = 'destination-out'; // Ch·∫ø ƒë·ªô t·∫©y
                } else if (button.id === 'tool-square') {
                    currentTool = 'square';
                    context.globalCompositeOperation = 'source-over';
                } else if (button.id === 'tool-circle') {
                    currentTool = 'circle';
                    context.globalCompositeOperation = 'source-over';
                }
            });
        });

        // L·∫•y t·ªça ƒë·ªô chu·ªôt ho·∫∑c ng√≥n tay m·ªôt c√°ch ch√≠nh x√°c
        // L·∫•y t·ªça ƒë·ªô chu·ªôt ho·∫∑c ng√≥n tay m·ªôt c√°ch ch√≠nh x√°c
        function getCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            let x, y;
            if (e.touches) {
                x = (e.touches[0].clientX - rect.left) * canvas.width / rect.width;
                y = (e.touches[0].clientY - rect.top) * canvas.height / rect.height;
            } else {
                x = (e.clientX - rect.left) * canvas.width / rect.width;
                y = (e.clientY - rect.top) * canvas.height / rect.height;
            }
            return [x, y];
        }

        // B·∫Øt ƒë·∫ßu v·∫Ω (mousedown/touchstart)
        function startDrawing(e) {
            isDrawing = true;
            [lastX, lastY] = getCoordinates(e);
            [startX, startY] = [lastX, lastY]; // L∆∞u ƒëi·ªÉm b·∫Øt ƒë·∫ßu cho h√¨nh kh·ªëi

            // ƒê·ªëi v·ªõi c√¥ng c·ª• v·∫Ω t·ª± do ho·∫∑c t·∫©y, b·∫Øt ƒë·∫ßu m·ªôt ƒë∆∞·ªùng v·∫Ω m·ªõi
            if (currentTool === 'pencil' || currentTool === 'eraser') {
                context.beginPath();
                context.moveTo(lastX, lastY);
            }
            // ƒê·ªëi v·ªõi c√°c c√¥ng c·ª• h√¨nh kh·ªëi, l∆∞u l·∫°i tr·∫°ng th√°i canvas hi·ªán t·∫°i
            else if (currentTool === 'square' || currentTool === 'circle') {
                canvasSnapshot = context.getImageData(0, 0, canvas.width, canvas.height);
            }
        }

        // ƒêang v·∫Ω (mousemove/touchmove)
        function draw(e) {
            if (!isDrawing) return;
            const [x, y] = getCoordinates(e);

            if (currentTool === 'pencil' || currentTool === 'eraser') {
                // Ti·∫øp t·ª•c ƒë∆∞·ªùng v·∫Ω t·ª´ v·ªã tr√≠ cu·ªëi c√πng ƒë·∫øn v·ªã tr√≠ hi·ªán t·∫°i
                context.lineTo(x, y);
                context.strokeStyle = currentTool === 'eraser' ? '#ffffff' : colorPicker.value;
                context.lineWidth = brushSizeSlider.value;
                context.stroke();
                [lastX, lastY] = [x, y];
            } else if (currentTool === 'square' || currentTool === 'circle') {
                // Logic v·∫Ω preview h√¨nh kh·ªëi
                context.putImageData(canvasSnapshot, 0, 0); // Kh√¥i ph·ª•c tr·∫°ng th√°i canvas
                drawShape(startX, startY, x, y, currentTool); // V·∫Ω h√¨nh kh·ªëi t·∫°m th·ªùi
            }
        }
        
        // K·∫øt th√∫c v·∫Ω (mouseup/touchend)
        function stopDrawing(e) {
            if (!isDrawing) return;
            isDrawing = false;
            
            if (currentTool === 'square' || currentTool === 'circle') {
                const [endX, endY] = getCoordinates(e);
                context.putImageData(canvasSnapshot, 0, 0); // Kh√¥i ph·ª•c tr·∫°ng th√°i canvas l·∫ßn cu·ªëi
                drawShape(startX, startY, endX, endY, currentTool); // V·∫Ω h√¨nh kh·ªëi c·ªë ƒë·ªãnh
            } else if (currentTool === 'pencil' || currentTool === 'eraser') {
                context.closePath(); // K·∫øt th√∫c ƒë∆∞·ªùng v·∫Ω
            }
        }
        
        // H√†m v·∫Ω h√¨nh kh·ªëi
        function drawShape(x1, y1, x2, y2, shape) {
            const width = x2 - x1;
            const height = y2 - y1;
            context.beginPath();
            
            if (shape === 'square') {
                context.strokeStyle = colorPicker.value;
                context.lineWidth = brushSizeSlider.value;
                context.rect(x1, y1, width, height);
            } else if (shape === 'circle') {
                const radiusX = Math.abs(width) / 2;
                const radiusY = Math.abs(height) / 2;
                const centerX = x1 + width / 2;
                const centerY = y1 + height / 2;

                // V·∫Ω h√¨nh elip
                context.save();
                context.beginPath();
                context.strokeStyle = colorPicker.value;
                context.lineWidth = brushSizeSlider.value;
                context.translate(centerX, centerY);
                context.scale(1, height / width);
                context.arc(0, 0, radiusX, 0, 2 * Math.PI);
                context.restore();
            }
            
            context.stroke();
            context.closePath();
        }

        // G√°n c√°c s·ª± ki·ªán cho canvas
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            draw(e);
        });
        canvas.addEventListener('touchend', stopDrawing);

        // X·ª≠ l√Ω s·ª± ki·ªán n√∫t x√≥a
        clearButton.addEventListener('click', () => {
            context.fillStyle = '#ffffff';
            context.fillRect(0, 0, canvas.width, canvas.height);
        });

        // X·ª≠ l√Ω s·ª± ki·ªán n√∫t l∆∞u ·∫£nh
        saveButton.addEventListener('click', () => {
            const dataURL = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'hinh-ve-cua-toi.png';
            link.href = dataURL;
            link.click();
        });

        // ƒê·∫£m b·∫£o canvas c√≥ k√≠ch th∆∞·ªõc ch√≠nh x√°c khi trang ƒë∆∞·ª£c t·∫£i v√† thay ƒë·ªïi k√≠ch th∆∞·ªõc
        function resizeCanvas() {
            // L∆∞u n·ªôi dung hi·ªán t·∫°i c·ªßa canvas
            let imageData = null;
            // Ch·ªâ l·∫•y d·ªØ li·ªáu n·∫øu canvas c√≥ k√≠ch th∆∞·ªõc h·ª£p l·ªá
            if (canvas.width > 0 && canvas.height > 0) {
                imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            }
        
            // C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc canvas d·ª±a tr√™n k√≠ch th∆∞·ªõc c·ªßa th·∫ª cha
            const rect = canvas.parentNode.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            // Kh√¥i ph·ª•c n·ªôi dung ƒë√£ l∆∞u n·∫øu c√≥
            if (imageData) {
                context.putImageData(imageData, 0, 0);
            } else {
                // N·∫øu kh√¥ng c√≥ n·ªôi dung, t√¥ m√†u tr·∫Øng cho n·ªÅn
                context.fillStyle = '#ffffff';
                context.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>
